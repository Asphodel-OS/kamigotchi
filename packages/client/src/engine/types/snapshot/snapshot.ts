// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.27.3
// source: snapshot.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import { type CallContext, type CallOptions } from 'nice-grpc-common';

export const protobufPackage = 'snapshot';

export interface State {
  componentIdx: number;
  entityIdx: number;
  data: Uint8Array;
  eventType: number;
}

export interface StateSnapshot {
  state: State[];
  stateComponents: Component[];
  stateEntities: Entity[];
  BlockNumber: number;
  worldAddress: string;
  stateHash: string;
}

export interface Worlds {
  worldAddress: string[];
}

export interface Component {
  componentIdx: number;
  componentId: string;
}

export interface Components {
  components: Component[];
}

export interface ComponentReply {
  components: Component[];
}

export interface Entity {
  entityIdx: number;
  entityId: Uint8Array;
}

export interface EntityReply {
  entities: Entity[];
}

export interface Block {
  blockNumber: number;
}

export interface BlockReply {
  blockNumber: number;
}

/** The response message containing the current state, hash of that state, and the block number of that state. */
export interface StateReply {
  state: State[];
}

/** The request message for the latest chunked ECS state changes from a specific block */
export interface StateRequest {
  worldAddress: string;
  numChunks?: number | undefined;
  blockNum: number;
}

/** The request message for the latest block based on latest ECS state. */
export interface StateBlockRequest {
  worldAddress: string;
}

/** The request message for all worlds. */
export interface WorldsRequest {}

/** The request message for all components */
export interface ComponentsRequest {
  worldAddress: string;
}

export interface EntitiesRequest {
  worldAddress: string;
  numChunks?: number | undefined;
  blockNum: number;
}

function createBaseState(): State {
  return { componentIdx: 0, entityIdx: 0, data: new Uint8Array(0), eventType: 0 };
}

export const State: MessageFns<State> = {
  encode(message: State, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.componentIdx !== 0) {
      writer.uint32(8).uint32(message.componentIdx);
    }
    if (message.entityIdx !== 0) {
      writer.uint32(16).uint32(message.entityIdx);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.eventType !== 0) {
      writer.uint32(32).uint32(message.eventType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): State {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.componentIdx = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entityIdx = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventType = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<State>): State {
    return State.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<State>): State {
    const message = createBaseState();
    message.componentIdx = object.componentIdx ?? 0;
    message.entityIdx = object.entityIdx ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    message.eventType = object.eventType ?? 0;
    return message;
  },
};

function createBaseStateSnapshot(): StateSnapshot {
  return {
    state: [],
    stateComponents: [],
    stateEntities: [],
    BlockNumber: 0,
    worldAddress: '',
    stateHash: '',
  };
}

export const StateSnapshot: MessageFns<StateSnapshot> = {
  encode(message: StateSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.state) {
      State.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.stateComponents) {
      Component.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.stateEntities) {
      Entity.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.BlockNumber !== 0) {
      writer.uint32(32).uint64(message.BlockNumber);
    }
    if (message.worldAddress !== '') {
      writer.uint32(42).string(message.worldAddress);
    }
    if (message.stateHash !== '') {
      writer.uint32(50).string(message.stateHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.state.push(State.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateComponents.push(Component.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stateEntities.push(Entity.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.BlockNumber = longToNumber(reader.uint64());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.worldAddress = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stateHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StateSnapshot>): StateSnapshot {
    return StateSnapshot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateSnapshot>): StateSnapshot {
    const message = createBaseStateSnapshot();
    message.state = object.state?.map((e) => State.fromPartial(e)) || [];
    message.stateComponents = object.stateComponents?.map((e) => Component.fromPartial(e)) || [];
    message.stateEntities = object.stateEntities?.map((e) => Entity.fromPartial(e)) || [];
    message.BlockNumber = object.BlockNumber ?? 0;
    message.worldAddress = object.worldAddress ?? '';
    message.stateHash = object.stateHash ?? '';
    return message;
  },
};

function createBaseWorlds(): Worlds {
  return { worldAddress: [] };
}

export const Worlds: MessageFns<Worlds> = {
  encode(message: Worlds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.worldAddress) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worlds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorlds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.worldAddress.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Worlds>): Worlds {
    return Worlds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Worlds>): Worlds {
    const message = createBaseWorlds();
    message.worldAddress = object.worldAddress?.map((e) => e) || [];
    return message;
  },
};

function createBaseComponent(): Component {
  return { componentIdx: 0, componentId: '' };
}

export const Component: MessageFns<Component> = {
  encode(message: Component, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.componentIdx !== 0) {
      writer.uint32(8).uint32(message.componentIdx);
    }
    if (message.componentId !== '') {
      writer.uint32(18).string(message.componentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Component {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.componentIdx = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.componentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Component>): Component {
    return Component.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Component>): Component {
    const message = createBaseComponent();
    message.componentIdx = object.componentIdx ?? 0;
    message.componentId = object.componentId ?? '';
    return message;
  },
};

function createBaseComponents(): Components {
  return { components: [] };
}

export const Components: MessageFns<Components> = {
  encode(message: Components, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Components {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Components>): Components {
    return Components.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Components>): Components {
    const message = createBaseComponents();
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComponentReply(): ComponentReply {
  return { components: [] };
}

export const ComponentReply: MessageFns<ComponentReply> = {
  encode(message: ComponentReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComponentReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponentReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ComponentReply>): ComponentReply {
    return ComponentReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComponentReply>): ComponentReply {
    const message = createBaseComponentReply();
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEntity(): Entity {
  return { entityIdx: 0, entityId: new Uint8Array(0) };
}

export const Entity: MessageFns<Entity> = {
  encode(message: Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityIdx !== 0) {
      writer.uint32(8).uint32(message.entityIdx);
    }
    if (message.entityId.length !== 0) {
      writer.uint32(18).bytes(message.entityId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entityIdx = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityId = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Entity>): Entity {
    return Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entity>): Entity {
    const message = createBaseEntity();
    message.entityIdx = object.entityIdx ?? 0;
    message.entityId = object.entityId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEntityReply(): EntityReply {
  return { entities: [] };
}

export const EntityReply: MessageFns<EntityReply> = {
  encode(message: EntityReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entities) {
      Entity.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entities.push(Entity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EntityReply>): EntityReply {
    return EntityReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityReply>): EntityReply {
    const message = createBaseEntityReply();
    message.entities = object.entities?.map((e) => Entity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlock(): Block {
  return { blockNumber: 0 };
}

export const Block: MessageFns<Block> = {
  encode(message: Block, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockNumber !== 0) {
      writer.uint32(8).uint64(message.blockNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Block {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.blockNumber = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Block>): Block {
    return Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Block>): Block {
    const message = createBaseBlock();
    message.blockNumber = object.blockNumber ?? 0;
    return message;
  },
};

function createBaseBlockReply(): BlockReply {
  return { blockNumber: 0 };
}

export const BlockReply: MessageFns<BlockReply> = {
  encode(message: BlockReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockNumber !== 0) {
      writer.uint32(8).uint64(message.blockNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.blockNumber = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BlockReply>): BlockReply {
    return BlockReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockReply>): BlockReply {
    const message = createBaseBlockReply();
    message.blockNumber = object.blockNumber ?? 0;
    return message;
  },
};

function createBaseStateReply(): StateReply {
  return { state: [] };
}

export const StateReply: MessageFns<StateReply> = {
  encode(message: StateReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.state) {
      State.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.state.push(State.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StateReply>): StateReply {
    return StateReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateReply>): StateReply {
    const message = createBaseStateReply();
    message.state = object.state?.map((e) => State.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStateRequest(): StateRequest {
  return { worldAddress: '', numChunks: undefined, blockNum: 0 };
}

export const StateRequest: MessageFns<StateRequest> = {
  encode(message: StateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.worldAddress !== '') {
      writer.uint32(10).string(message.worldAddress);
    }
    if (message.numChunks !== undefined) {
      writer.uint32(16).uint32(message.numChunks);
    }
    if (message.blockNum !== 0) {
      writer.uint32(24).uint64(message.blockNum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.worldAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numChunks = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockNum = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StateRequest>): StateRequest {
    return StateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateRequest>): StateRequest {
    const message = createBaseStateRequest();
    message.worldAddress = object.worldAddress ?? '';
    message.numChunks = object.numChunks ?? undefined;
    message.blockNum = object.blockNum ?? 0;
    return message;
  },
};

function createBaseStateBlockRequest(): StateBlockRequest {
  return { worldAddress: '' };
}

export const StateBlockRequest: MessageFns<StateBlockRequest> = {
  encode(message: StateBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.worldAddress !== '') {
      writer.uint32(10).string(message.worldAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.worldAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StateBlockRequest>): StateBlockRequest {
    return StateBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateBlockRequest>): StateBlockRequest {
    const message = createBaseStateBlockRequest();
    message.worldAddress = object.worldAddress ?? '';
    return message;
  },
};

function createBaseWorldsRequest(): WorldsRequest {
  return {};
}

export const WorldsRequest: MessageFns<WorldsRequest> = {
  encode(_: WorldsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorldsRequest>): WorldsRequest {
    return WorldsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<WorldsRequest>): WorldsRequest {
    const message = createBaseWorldsRequest();
    return message;
  },
};

function createBaseComponentsRequest(): ComponentsRequest {
  return { worldAddress: '' };
}

export const ComponentsRequest: MessageFns<ComponentsRequest> = {
  encode(message: ComponentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.worldAddress !== '') {
      writer.uint32(10).string(message.worldAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComponentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.worldAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ComponentsRequest>): ComponentsRequest {
    return ComponentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComponentsRequest>): ComponentsRequest {
    const message = createBaseComponentsRequest();
    message.worldAddress = object.worldAddress ?? '';
    return message;
  },
};

function createBaseEntitiesRequest(): EntitiesRequest {
  return { worldAddress: '', numChunks: undefined, blockNum: 0 };
}

export const EntitiesRequest: MessageFns<EntitiesRequest> = {
  encode(message: EntitiesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.worldAddress !== '') {
      writer.uint32(10).string(message.worldAddress);
    }
    if (message.numChunks !== undefined) {
      writer.uint32(16).uint32(message.numChunks);
    }
    if (message.blockNum !== 0) {
      writer.uint32(24).uint64(message.blockNum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntitiesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntitiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.worldAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numChunks = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockNum = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EntitiesRequest>): EntitiesRequest {
    return EntitiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntitiesRequest>): EntitiesRequest {
    const message = createBaseEntitiesRequest();
    message.worldAddress = object.worldAddress ?? '';
    message.numChunks = object.numChunks ?? undefined;
    message.blockNum = object.blockNum ?? 0;
    return message;
  },
};

/** The Snapshot Service definition. */
export type StateSnapshotServiceDefinition = typeof StateSnapshotServiceDefinition;
export const StateSnapshotServiceDefinition = {
  name: 'StateSnapshotService',
  fullName: 'snapshot.StateSnapshotService',
  methods: {
    /** Requests the latest ECS state in stream format, which will chunk the state. */
    getState: {
      name: 'GetState',
      requestType: StateRequest,
      requestStream: false,
      responseType: StateReply,
      responseStream: true,
      options: {},
    },
    /** Requests the latest block number based on the latest ECS state. */
    getStateBlock: {
      name: 'GetStateBlock',
      requestType: StateBlockRequest,
      requestStream: false,
      responseType: BlockReply,
      responseStream: false,
      options: {},
    },
    /** Requests a list of known worlds based on chain state. */
    getWorlds: {
      name: 'GetWorlds',
      requestType: WorldsRequest,
      requestStream: false,
      responseType: Worlds,
      responseStream: false,
      options: {},
    },
    /** components */
    getComponents: {
      name: 'GetComponents',
      requestType: ComponentsRequest,
      requestStream: false,
      responseType: ComponentReply,
      responseStream: false,
      options: {},
    },
    /** entities */
    getEntities: {
      name: 'GetEntities',
      requestType: EntitiesRequest,
      requestStream: false,
      responseType: EntityReply,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface StateSnapshotServiceImplementation<CallContextExt = {}> {
  /** Requests the latest ECS state in stream format, which will chunk the state. */
  getState(
    request: StateRequest,
    context: CallContext & CallContextExt
  ): ServerStreamingMethodResult<DeepPartial<StateReply>>;
  /** Requests the latest block number based on the latest ECS state. */
  getStateBlock(
    request: StateBlockRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<BlockReply>>;
  /** Requests a list of known worlds based on chain state. */
  getWorlds(
    request: WorldsRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<Worlds>>;
  /** components */
  getComponents(
    request: ComponentsRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<ComponentReply>>;
  /** entities */
  getEntities(
    request: EntitiesRequest,
    context: CallContext & CallContextExt
  ): ServerStreamingMethodResult<DeepPartial<EntityReply>>;
}

export interface StateSnapshotServiceClient<CallOptionsExt = {}> {
  /** Requests the latest ECS state in stream format, which will chunk the state. */
  getState(
    request: DeepPartial<StateRequest>,
    options?: CallOptions & CallOptionsExt
  ): AsyncIterable<StateReply>;
  /** Requests the latest block number based on the latest ECS state. */
  getStateBlock(
    request: DeepPartial<StateBlockRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<BlockReply>;
  /** Requests a list of known worlds based on chain state. */
  getWorlds(
    request: DeepPartial<WorldsRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<Worlds>;
  /** components */
  getComponents(
    request: DeepPartial<ComponentsRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<ComponentReply>;
  /** entities */
  getEntities(
    request: DeepPartial<EntitiesRequest>,
    options?: CallOptions & CallOptionsExt
  ): AsyncIterable<EntityReply>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return num;
}

export type ServerStreamingMethodResult<Response> = {
  [Symbol.asyncIterator](): AsyncIterator<Response, void>;
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
