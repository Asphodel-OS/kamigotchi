// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: kamigaze.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import { type CallContext, type CallOptions } from 'nice-grpc-common';

export const protobufPackage = 'kamigaze';

/** Base type */
export interface Entity {
  idx: number;
  id: Uint8Array;
}

export interface Component {
  idx: number;
  id: Uint8Array;
}

export interface State {
  packedIdx: number;
  data: Uint8Array;
}

export interface ECSEvent {
  eventType: string;
  componentId: string;
  entityId: string;
  value?: Uint8Array | undefined;
  txHash: string;
  txMetadata?: TxMetadata | undefined;
}

export interface TxMetadata {
  to: string;
  data: Uint8Array;
  value: number;
}

/** Replies */
export interface EntitiesResponse {
  entities: Entity[];
  pending: number;
}

export interface ComponentsResponse {
  components: Component[];
}

export interface BlockResponse {
  blockNumber: number;
  nonce: number;
}

export interface StateResponse {
  state: State[];
  pending: number;
}

export interface StreamResponse {
  blockNumber: number;
  blockHash: string;
  blockTimestamp: number;
  transactionsConfirmed: string[];
  ecsEvents: ECSEvent[];
  prevBlockNumber: number;
}

/** Requests */
export interface BlockRequest {}

export interface ComponentsRequest {
  fromIdx: number;
}

export interface EntitiesRequest {
  fromIdx: number;
}

export interface StateRequest {
  fromBlock: number;
  removals?: boolean | undefined;
}

export interface StreamRequest {
  worldAddress: string;
  blockNumber: boolean;
  blockHash: boolean;
  blockTimestamp: boolean;
  transactionsConfirmed: boolean;
  ecsEvents: boolean;
  ecsEventsIncludeTxMetadata: boolean;
}

function createBaseEntity(): Entity {
  return { idx: 0, id: new Uint8Array(0) };
}

export const Entity: MessageFns<Entity> = {
  encode(message: Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idx !== 0) {
      writer.uint32(8).uint32(message.idx);
    }
    if (message.id.length !== 0) {
      writer.uint32(18).bytes(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.idx = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Entity>): Entity {
    return Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entity>): Entity {
    const message = createBaseEntity();
    message.idx = object.idx ?? 0;
    message.id = object.id ?? new Uint8Array(0);
    return message;
  },
};

function createBaseComponent(): Component {
  return { idx: 0, id: new Uint8Array(0) };
}

export const Component: MessageFns<Component> = {
  encode(message: Component, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idx !== 0) {
      writer.uint32(8).uint32(message.idx);
    }
    if (message.id.length !== 0) {
      writer.uint32(18).bytes(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Component {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.idx = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Component>): Component {
    return Component.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Component>): Component {
    const message = createBaseComponent();
    message.idx = object.idx ?? 0;
    message.id = object.id ?? new Uint8Array(0);
    return message;
  },
};

function createBaseState(): State {
  return { packedIdx: 0, data: new Uint8Array(0) };
}

export const State: MessageFns<State> = {
  encode(message: State, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packedIdx !== 0) {
      writer.uint32(8).uint32(message.packedIdx);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): State {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.packedIdx = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<State>): State {
    return State.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<State>): State {
    const message = createBaseState();
    message.packedIdx = object.packedIdx ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseECSEvent(): ECSEvent {
  return {
    eventType: '',
    componentId: '',
    entityId: '',
    value: undefined,
    txHash: '',
    txMetadata: undefined,
  };
}

export const ECSEvent: MessageFns<ECSEvent> = {
  encode(message: ECSEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== '') {
      writer.uint32(10).string(message.eventType);
    }
    if (message.componentId !== '') {
      writer.uint32(18).string(message.componentId);
    }
    if (message.entityId !== '') {
      writer.uint32(26).string(message.entityId);
    }
    if (message.value !== undefined) {
      writer.uint32(34).bytes(message.value);
    }
    if (message.txHash !== '') {
      writer.uint32(42).string(message.txHash);
    }
    if (message.txMetadata !== undefined) {
      TxMetadata.encode(message.txMetadata, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ECSEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseECSEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.componentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.txMetadata = TxMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ECSEvent>): ECSEvent {
    return ECSEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ECSEvent>): ECSEvent {
    const message = createBaseECSEvent();
    message.eventType = object.eventType ?? '';
    message.componentId = object.componentId ?? '';
    message.entityId = object.entityId ?? '';
    message.value = object.value ?? undefined;
    message.txHash = object.txHash ?? '';
    message.txMetadata =
      object.txMetadata !== undefined && object.txMetadata !== null
        ? TxMetadata.fromPartial(object.txMetadata)
        : undefined;
    return message;
  },
};

function createBaseTxMetadata(): TxMetadata {
  return { to: '', data: new Uint8Array(0), value: 0 };
}

export const TxMetadata: MessageFns<TxMetadata> = {
  encode(message: TxMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.to !== '') {
      writer.uint32(18).string(message.to);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.value !== 0) {
      writer.uint32(32).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TxMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTxMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TxMetadata>): TxMetadata {
    return TxMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TxMetadata>): TxMetadata {
    const message = createBaseTxMetadata();
    message.to = object.to ?? '';
    message.data = object.data ?? new Uint8Array(0);
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseEntitiesResponse(): EntitiesResponse {
  return { entities: [], pending: 0 };
}

export const EntitiesResponse: MessageFns<EntitiesResponse> = {
  encode(message: EntitiesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entities) {
      Entity.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pending !== 0) {
      writer.uint32(16).uint32(message.pending);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntitiesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntitiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entities.push(Entity.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pending = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EntitiesResponse>): EntitiesResponse {
    return EntitiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntitiesResponse>): EntitiesResponse {
    const message = createBaseEntitiesResponse();
    message.entities = object.entities?.map((e) => Entity.fromPartial(e)) || [];
    message.pending = object.pending ?? 0;
    return message;
  },
};

function createBaseComponentsResponse(): ComponentsResponse {
  return { components: [] };
}

export const ComponentsResponse: MessageFns<ComponentsResponse> = {
  encode(message: ComponentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComponentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ComponentsResponse>): ComponentsResponse {
    return ComponentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComponentsResponse>): ComponentsResponse {
    const message = createBaseComponentsResponse();
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockResponse(): BlockResponse {
  return { blockNumber: 0, nonce: 0 };
}

export const BlockResponse: MessageFns<BlockResponse> = {
  encode(message: BlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockNumber !== 0) {
      writer.uint32(8).uint64(message.blockNumber);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockNumber = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BlockResponse>): BlockResponse {
    return BlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockResponse>): BlockResponse {
    const message = createBaseBlockResponse();
    message.blockNumber = object.blockNumber ?? 0;
    message.nonce = object.nonce ?? 0;
    return message;
  },
};

function createBaseStateResponse(): StateResponse {
  return { state: [], pending: 0 };
}

export const StateResponse: MessageFns<StateResponse> = {
  encode(message: StateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.state) {
      State.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pending !== 0) {
      writer.uint32(16).uint32(message.pending);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.state.push(State.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pending = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StateResponse>): StateResponse {
    return StateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateResponse>): StateResponse {
    const message = createBaseStateResponse();
    message.state = object.state?.map((e) => State.fromPartial(e)) || [];
    message.pending = object.pending ?? 0;
    return message;
  },
};

function createBaseStreamResponse(): StreamResponse {
  return {
    blockNumber: 0,
    blockHash: '',
    blockTimestamp: 0,
    transactionsConfirmed: [],
    ecsEvents: [],
    prevBlockNumber: 0,
  };
}

export const StreamResponse: MessageFns<StreamResponse> = {
  encode(message: StreamResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockNumber !== 0) {
      writer.uint32(8).uint32(message.blockNumber);
    }
    if (message.blockHash !== '') {
      writer.uint32(18).string(message.blockHash);
    }
    if (message.blockTimestamp !== 0) {
      writer.uint32(24).uint32(message.blockTimestamp);
    }
    for (const v of message.transactionsConfirmed) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.ecsEvents) {
      ECSEvent.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.prevBlockNumber !== 0) {
      writer.uint32(48).uint32(message.prevBlockNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockNumber = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blockTimestamp = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transactionsConfirmed.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ecsEvents.push(ECSEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.prevBlockNumber = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StreamResponse>): StreamResponse {
    return StreamResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamResponse>): StreamResponse {
    const message = createBaseStreamResponse();
    message.blockNumber = object.blockNumber ?? 0;
    message.blockHash = object.blockHash ?? '';
    message.blockTimestamp = object.blockTimestamp ?? 0;
    message.transactionsConfirmed = object.transactionsConfirmed?.map((e) => e) || [];
    message.ecsEvents = object.ecsEvents?.map((e) => ECSEvent.fromPartial(e)) || [];
    message.prevBlockNumber = object.prevBlockNumber ?? 0;
    return message;
  },
};

function createBaseBlockRequest(): BlockRequest {
  return {};
}

export const BlockRequest: MessageFns<BlockRequest> = {
  encode(_: BlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BlockRequest>): BlockRequest {
    return BlockRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BlockRequest>): BlockRequest {
    const message = createBaseBlockRequest();
    return message;
  },
};

function createBaseComponentsRequest(): ComponentsRequest {
  return { fromIdx: 0 };
}

export const ComponentsRequest: MessageFns<ComponentsRequest> = {
  encode(message: ComponentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromIdx !== 0) {
      writer.uint32(8).uint32(message.fromIdx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComponentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromIdx = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ComponentsRequest>): ComponentsRequest {
    return ComponentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComponentsRequest>): ComponentsRequest {
    const message = createBaseComponentsRequest();
    message.fromIdx = object.fromIdx ?? 0;
    return message;
  },
};

function createBaseEntitiesRequest(): EntitiesRequest {
  return { fromIdx: 0 };
}

export const EntitiesRequest: MessageFns<EntitiesRequest> = {
  encode(message: EntitiesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromIdx !== 0) {
      writer.uint32(8).uint32(message.fromIdx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntitiesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntitiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromIdx = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EntitiesRequest>): EntitiesRequest {
    return EntitiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntitiesRequest>): EntitiesRequest {
    const message = createBaseEntitiesRequest();
    message.fromIdx = object.fromIdx ?? 0;
    return message;
  },
};

function createBaseStateRequest(): StateRequest {
  return { fromBlock: 0, removals: undefined };
}

export const StateRequest: MessageFns<StateRequest> = {
  encode(message: StateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromBlock !== 0) {
      writer.uint32(8).uint32(message.fromBlock);
    }
    if (message.removals !== undefined) {
      writer.uint32(24).bool(message.removals);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromBlock = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.removals = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StateRequest>): StateRequest {
    return StateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateRequest>): StateRequest {
    const message = createBaseStateRequest();
    message.fromBlock = object.fromBlock ?? 0;
    message.removals = object.removals ?? undefined;
    return message;
  },
};

function createBaseStreamRequest(): StreamRequest {
  return {
    worldAddress: '',
    blockNumber: false,
    blockHash: false,
    blockTimestamp: false,
    transactionsConfirmed: false,
    ecsEvents: false,
    ecsEventsIncludeTxMetadata: false,
  };
}

export const StreamRequest: MessageFns<StreamRequest> = {
  encode(message: StreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.worldAddress !== '') {
      writer.uint32(10).string(message.worldAddress);
    }
    if (message.blockNumber !== false) {
      writer.uint32(16).bool(message.blockNumber);
    }
    if (message.blockHash !== false) {
      writer.uint32(24).bool(message.blockHash);
    }
    if (message.blockTimestamp !== false) {
      writer.uint32(32).bool(message.blockTimestamp);
    }
    if (message.transactionsConfirmed !== false) {
      writer.uint32(40).bool(message.transactionsConfirmed);
    }
    if (message.ecsEvents !== false) {
      writer.uint32(48).bool(message.ecsEvents);
    }
    if (message.ecsEventsIncludeTxMetadata !== false) {
      writer.uint32(56).bool(message.ecsEventsIncludeTxMetadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.worldAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockNumber = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blockHash = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.blockTimestamp = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.transactionsConfirmed = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ecsEvents = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ecsEventsIncludeTxMetadata = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StreamRequest>): StreamRequest {
    return StreamRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamRequest>): StreamRequest {
    const message = createBaseStreamRequest();
    message.worldAddress = object.worldAddress ?? '';
    message.blockNumber = object.blockNumber ?? false;
    message.blockHash = object.blockHash ?? false;
    message.blockTimestamp = object.blockTimestamp ?? false;
    message.transactionsConfirmed = object.transactionsConfirmed ?? false;
    message.ecsEvents = object.ecsEvents ?? false;
    message.ecsEventsIncludeTxMetadata = object.ecsEventsIncludeTxMetadata ?? false;
    return message;
  },
};

export type KamigazeServiceDefinition = typeof KamigazeServiceDefinition;
export const KamigazeServiceDefinition = {
  name: 'KamigazeService',
  fullName: 'kamigaze.KamigazeService',
  methods: {
    /** Requests the latest block number based on the latest ECS state. */
    getStateBlock: {
      name: 'GetStateBlock',
      requestType: BlockRequest,
      requestStream: false,
      responseType: BlockResponse,
      responseStream: false,
      options: {},
    },
    /** components */
    getComponents: {
      name: 'GetComponents',
      requestType: ComponentsRequest,
      requestStream: false,
      responseType: ComponentsResponse,
      responseStream: false,
      options: {},
    },
    /** entities */
    getEntities: {
      name: 'GetEntities',
      requestType: EntitiesRequest,
      requestStream: false,
      responseType: EntitiesResponse,
      responseStream: true,
      options: {},
    },
    /** Get State */
    getState: {
      name: 'GetState',
      requestType: StateRequest,
      requestStream: false,
      responseType: StateResponse,
      responseStream: true,
      options: {},
    },
    /**
     * Get Kills
     * rpc GetKills (KillsRequest) returns (stream KillsResponse) {}
     * KillFeed stream
     * rpc SubscribeToKillFeed(KillFeedRequest) returns (stream KillFeedResponse) {}
     * Stream
     */
    subscribeToStream: {
      name: 'SubscribeToStream',
      requestType: StreamRequest,
      requestStream: false,
      responseType: StreamResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface KamigazeServiceImplementation<CallContextExt = {}> {
  /** Requests the latest block number based on the latest ECS state. */
  getStateBlock(
    request: BlockRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<BlockResponse>>;
  /** components */
  getComponents(
    request: ComponentsRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<ComponentsResponse>>;
  /** entities */
  getEntities(
    request: EntitiesRequest,
    context: CallContext & CallContextExt
  ): ServerStreamingMethodResult<DeepPartial<EntitiesResponse>>;
  /** Get State */
  getState(
    request: StateRequest,
    context: CallContext & CallContextExt
  ): ServerStreamingMethodResult<DeepPartial<StateResponse>>;
  /**
   * Get Kills
   * rpc GetKills (KillsRequest) returns (stream KillsResponse) {}
   * KillFeed stream
   * rpc SubscribeToKillFeed(KillFeedRequest) returns (stream KillFeedResponse) {}
   * Stream
   */
  subscribeToStream(
    request: StreamRequest,
    context: CallContext & CallContextExt
  ): ServerStreamingMethodResult<DeepPartial<StreamResponse>>;
}

export interface KamigazeServiceClient<CallOptionsExt = {}> {
  /** Requests the latest block number based on the latest ECS state. */
  getStateBlock(
    request: DeepPartial<BlockRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<BlockResponse>;
  /** components */
  getComponents(
    request: DeepPartial<ComponentsRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<ComponentsResponse>;
  /** entities */
  getEntities(
    request: DeepPartial<EntitiesRequest>,
    options?: CallOptions & CallOptionsExt
  ): AsyncIterable<EntitiesResponse>;
  /** Get State */
  getState(
    request: DeepPartial<StateRequest>,
    options?: CallOptions & CallOptionsExt
  ): AsyncIterable<StateResponse>;
  /**
   * Get Kills
   * rpc GetKills (KillsRequest) returns (stream KillsResponse) {}
   * KillFeed stream
   * rpc SubscribeToKillFeed(KillFeedRequest) returns (stream KillFeedResponse) {}
   * Stream
   */
  subscribeToStream(
    request: DeepPartial<StreamRequest>,
    options?: CallOptions & CallOptionsExt
  ): AsyncIterable<StreamResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return num;
}

export type ServerStreamingMethodResult<Response> = {
  [Symbol.asyncIterator](): AsyncIterator<Response, void>;
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
