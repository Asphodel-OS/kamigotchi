import { readFile, rm, writeFile } from 'fs/promises';
import path from 'path';
import { extractIdFromFile, keccak256 } from '../../utils/ids';
import {
  componentRegisterPath,
  componentSchemaPath,
  contractsDir,
  deployConfigPath,
} from '../../utils/paths';

/**
 * Generate Component register.ts and component schemas in client
 */
export async function generateComponentSchemas(options?: { clear?: boolean }) {
  if (options?.clear) {
    console.log('Clearing component register output files', componentRegisterPath);
    await rm(path.join(componentRegisterPath), { force: true });
    console.log('Clearing component schema output files', componentSchemaPath);
    await rm(path.join(componentSchemaPath), { force: true });
  }

  const components: any[] = JSON.parse(
    await readFile(deployConfigPath, { encoding: 'utf8' })
  ).components;
  // adding ids
  components.map((comp) => {
    const id = extractIdFromFile(
      path.join(contractsDir, 'src/components', comp.comp + 'Component.sol')
    );
    comp.id = id;
    comp.encodedID = keccak256(id || '');
  });

  const ComponentsRegistry = `// Autogenerated using mud component-types
import { World } from '@mud-classic/recs';
import {
  defineBoolComponent,
  defineLoadingStateComponent,
  defineNumberArrayComponent,
  defineNumberComponent,
  defineStatComponent,
  defineStringComponent,
  defineTimelockComponent,
} from './definitions';

export type Components = ReturnType<typeof createComponents>;

// define functions for registration
export function createComponents(world: World) {
  return {
${components
  .map(
    (comp) =>
      `    ${comp.name}: ${parseCompTypeDef(comp.type, comp.FEtype)}(world, '${comp.name}', '${comp.id}'${comp.indexed ? ', true' : ''}),`
  )
  .join('\n')}

  // world components
  Components: defineStringComponent(world, 'Components', 'world.component.components'),
  Systems: defineStringComponent(world, 'Systems', 'world.component.systems'),

  // local components
  LoadingState: defineLoadingStateComponent(world),
  }
}`;

  // adding schemas to components[]
  const schemaMap = JSON.parse(
    await readFile(path.join(contractsDir, 'src/solecs/components/types/schema.json'), {
      encoding: 'utf8',
    })
  );
  components.map((comp) => {
    comp.schema = schemaMap[comp.type];
    if (comp.schema === undefined)
      throw new Error(`No schema found for ${comp.comp} (looking for ${comp.type})`);
  });

  const ComponentSchema = `// Autogenerated using mud component-types
export const ComponentsSchema = {
${components
  .map((comp) => {
    return `  '${comp.encodedID}': { keys: [${comp.schema.keys}], values: [${comp.schema.values}] },`;
  })
  .join('\n')}
};
`;

  console.log('writing component registry');
  await writeFile(componentRegisterPath, ComponentsRegistry);
  console.log('writing component schema');
  await writeFile(componentSchemaPath, ComponentSchema);
}

///////////////
// INTERNAL

const parseCompTypeDef = (type: string, override?: string): string => {
  if (override) type = override;
  const defBool = ['bool'];
  const defStat = ['Stat'];
  const defString = ['string', 'address', 'Coord'];
  const defNumber = ['uint32', 'uint256', 'int32', 'int256', 'number'];

  const isArray = type.includes('[]');
  if (isArray) type = type.replace('[]', '');

  let definer: string = '';
  if (defBool.includes(type)) definer = 'Bool';
  else if (defStat.includes(type)) definer = 'Stat';
  else if (defString.includes(type)) definer = 'String';
  else if (defNumber.includes(type)) definer = 'Number';
  else if (type === 'TimelockOp') definer = 'Timelock';

  return 'define' + definer + (isArray ? 'Array' : '') + 'Component';
};
